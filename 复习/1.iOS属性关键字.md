#### 1、对属性关键字的理解
属性关键字可以分为三种
- 读写权限类型
  - readonly, readwrite
- 原子类型
  - atomic, nonatomic
- 引用类型
  - retain/strong/copy, assign/unsafe_unretained, weak
- 其他一些编译时的关键字
  - nullable/nonullable, class, direct
 
#
##### 读写权限
- readonly, getter, setter readwrite

##### 原子类型
- atomic, noatomic
  - atomic只会保证赋值和取值的时候的线程安全：意思就是对成员变量的，不代表操作和访问
```swift
@property (atomic, assign) NSInteger innerInt;
self.innerInt = 0;
dispatch_apply(10000, dispatch_get_global_queue(0, 0), ^(size_t index) {
    _innerInt += 1;
    //_innerInt += 1 相当于 int temp = _innerInt + 1; _innerInt = temp
    //atomic 保证了_innerInt的线程安全，缺保证不了 temp的线程安全
});
NSLog(@"-------------%ld", _innerInt);//输出的值是不确定的


```
解析
atomic 保证的是数据读取的完整性，不会出现意外被释放，保证了getter、setter方法的完整性
atomic 所说的线程安全只是保证了getter和setter存取方法的线程安全，并不能保证整个对象是线程安全的
```swift
//setter 方法
{lock}
if (property != newValue) {
    [property release];
     property = [newValue retain];
}
{unlock}
//getter 方法
{lock}
return _currentValue
{unlock}
```
#
##### 引用类型
- retain/strong/copy, assign/unsafe_unretained, weak
######
- retain、strong 
  - 只能修饰对象都会使得所修饰的对象的引用计数 增加 1，
  - 只要对象的引用计数不为0,对象就无法释放，当计数为0时，系统会直接调用dealloc函数
  - 对对象强制设置为 nil 时，也会释放对象指向的内存

- copy
  - copy作为属性关键字时, 会在setter方法里面进行相应的copy操作
    - 当作用在可变对象时，会进行深拷贝操作
    - 当作用在不可变对象时，会进行浅拷贝操作
  - 方法返回的都是不可变对象

- assign/unsafe_retained
  - assign 可以作为基础数据类型和对象的修饰
  - 

####
- NSCopying - NSMutableCopying
  - 可对自定义对象实现相应的协议来支持一下两种操作
  - mutableCopy
    - 不是作为属性的关键字
    - 生成对象时都是深拷贝：即会生成新的对象，和内存地址，不会对老对象的引用计数产生影响
  - copy
    - 只有不可变对象进行copy时，才是浅拷贝：不会生成新的对象和地址，会增加对象的引用计数

