# 第一天 
##### 视图相关

- 底层知识`Core Animation`
- 

1、`Core Animation`简介
  `Core Animation`并不像英文描述的这样核心动画，做动画只是它其中的以部分功能而已，它更像是一个复合引擎，尽可能快的组合屏幕上不同的可视内容，其内容划分到三大层级树的体现中的图层树，另外两大树状结构分别是呈现树和渲染树。

我们通常使用的`UIView`及其派生类，都是属于视图，`CALayer`相关的的属性均为`图层属性`。每个`UIView`视图都有一个`CALayer`实例的图层属性，视图负责创建并管理这个图层，来确保当子视图在图层树中被添加或者移除时候，其关联的图层在呈现树中有相同的操作。

iOS视图中的3个树形结构
- 图层树 < - > Flutter中的 Widget
- 渲染树 < - > Flutter中的 Element
- 呈现树 < - > Flutter中的 RanderObject

`UIView`和`CALayer`的两个平行的层级关系的设计是六大设计原则中的`单一职责`的体现，同时考虑多平台的通用性设计。`UIView`仅仅是对`CALayer`的一个分装，并提供处理触摸事件的功能，以及CoreAnimation底层方法的高级接口。

`CALayer`具备一些 `UIView`无法处理一些能力。
  - 阴影、 圆角、 带颜色的边框
  - 3D变换、 非矩形范围
  - 透明遮罩、 多级非线性动画

一个视图系统会自动创建和关联一个图层，同时支持添加无数多个子图层。
使用关联图层而不是`CALayer`的好处在于，能使用到底层特性的同时，也可以使用到UIView的高级API，比如说自动排版、布局和事件处理。一些情况可以考虑直接使用`CALayer`或者及其子类 
 - 开发可以在Mac OS 上运行的跨平台应用
 - 不想创建额外的UIView去封装
 - 做一些对性能特别挑剔的工作，比如说帧动画，直接修改`CALayer` 上的 `contents`属性


`CALayer`的`contentRect`属性允许我们在图层边框里显示寄宿图的一个子域。这里比`contentsGravity`灵活许多。和bounds，frame不同，contentsRect不是按点来计算的，它使用了单位坐标，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）。所以他们是相对与寄宿图的尺寸的。
默认的contentsRect是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，
很典型的一个应用就是图片拼合，图片拼合可以打包整合一张大图一次性载入，相比于多次载入，在内存和载入时间、渲染性能上都有提升。

`contentsCenter`指定拉伸区域，并不会影响到寄宿图的显示，除非整个图层的大小发生了变化。也是一个`CGRect` xy分别是起点 wh就定义了大小

设置寄宿图除了`contents`属性，还可以重写`UIView`的 `-drawRect:`方法来自定义绘制。
但这个方法会有弊端：
 - 会浪费CPU资源和内存
   - 当视图在屏幕上出现的时候`-drawRect:`会被自动调用，绘制好的寄宿图会被缓存起来直到它需要被更新
   - 会把一部分GPU该做的工作转接到CPU上
  
`-drawRect:`方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。


通常，图层是根据它们子图层的sublayers出现的顺序来类绘制的，这就是所谓的画家的算法--就像一个画家在墙上作画--后被绘制上的图层将会遮盖住之前的图层，但是通过增加图层的zPosition，就可以把图层向用户视角的方向前置，于是它就在所有其他图层的前面了（或者至少是小于它的zPosition值的图层的前面）。
当调用图层的-hitTest:方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的zPosition属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。
这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的zPosition值较小，但是在图层树中的顺序靠前。








(1)这三个树状结构的设计体现也在Flutter上有相关体现。[Flutter渲染原理](https://www.jianshu.com/p/bdb49f53fcd6)
(2)一些常见的app中使用拼合技术LayerSprites（https://github.com/nicklockwood/LayerSprites)，它能够读取Cocos2D格式中的拼合图并在普通的Core Animation层中显示出来。