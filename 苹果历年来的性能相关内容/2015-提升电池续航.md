##### 电池续航
- 电池续航也是用户体验上很重要的不可缺的一部分

  
可从如下方面优化，减少电量的使用
  - CPU
    - 减少和对工作进行优先性分类
      - 在后台是，尽量少的工作
        - 后台应用一些常见的浪费点的地方
        - 在进入后台是，暂停一些活动
        - 在进入活跃状态时，激活一些暂停的活动
      - 使用QOS来对任务进行优先级分类
      - 减少使用Timer
        - 不使用Timer来获取事件通知
        - 使用GCD工具进行同步而不是计时器
        - 设置合理的超时时间
        - 不需要时，注意需要释放掉timer
        - 在系统层面，使用合理的误差值，可批量进行Timer处理
      - 减少IO
        - 设置对应的文件访问权限
      - 关注低电量模式下的事情
  - 网络操作
    - 减少网络访问
      - 减少数据大小
        - 降低媒体的质量和大小
        - 压缩数据
      - 避免冗余传输
        - 缓存数据
        - 使用可暂停和恢复的传输
      - 处理相关错误
        - 检查网络信号
        - 设置合理的超时时间
        - 使用重试策略
    - 延迟网络访问
      - 批量传输
      - 推迟可推迟的网络操作
        - 使用后台会话选项
    - 使用Voip
  - 图形，动画，音视频
  - 定位
    - 该用就用，不用就释放
  - 运动
    - 该用就用，不用就释放
  - 蓝牙
    - 该用就用，不用就释放

---
正文：

所有应用程序都消耗能源——无论何时执行网络操作、更新用户界面或在CPU上运行代码。随着用户越来越依赖电池电量，以及应用程序的激增，能源效率成为用户体验不可或缺的一部分。

良好的用户体验需要：
 - 电池续航能力很好
 - 惊人的速度777777777777777777777777777777666666666666666666666666666
 - 快速响应


###### 尽可能减少后台工作
后台APP浪费能源的常见原因：
 - 后台活动完成后不通知系统
 - 播放无声音频
 - 执行位置更新
 - 与蓝牙配件交互
 - 推迟的下载

当app不活跃时或者退到后台，应当暂停App的活动

`
The applicationWillResignActive: method is called when your app enters an inactive state, such as when a phone call or text message comes in, or the user switches to another app and your app begins transitioning to a background state. This is a good place to pause activity, save data, and prepare for possible suspension. 
`
```Objective-c
- (void)applicationWillResignActive:(UIApplication *)application {
   // Halt operations, animations, and UI updates
}
```

`
The applicationDidEnterBackground: method is called immediately after your app enters a background state. Stop any operations, animations, and UI updates immediately.
`

>iOS allows only a few seconds for the applicationDidEnterBackground method to run. If your app needs more time to finish performing essential user initiated tasks, it should request more background execution time—the system allows up to a few more minutes of time on request. Call the beginBackgroundTaskWithExpirationHandler: method and pass it a handler, to be called if the extra time runs out. Next, run the remaining tasks on a dispatch queue or secondary thread.

>When background tasks are done, call the endBackgroundTask: method to let the system know processing is complete. If you don’t call this method and background execution time exhausts, then the completion handler is called to give you one last shot at wrapping things up. After that, your app is suspended.

>Once your app finishes performing background tasks, don’t wait for the system to call the expiration handler. Call endBackgroundTask: as soon as your app is done performing background tasks.


`
The applicationWillEnterForeground: method is called immediately before your app transitions from a background app to the active app. Start resuming operations, loading data, reinitializing the UI, and getting your app ready for the user.
`

```Objc
- (void)applicationWillEnterForeground:(UIApplication *)application {
   // Prepare to resume operations, animations, and UI updates
}
```

`
The applicationDidBecomeActive: method is called immediately after your app becomes the active app, after being launched by the system or transitioning from a background or inactive state. Fully resume any operations that were halted. 
`

---
##### Prioritize Work with Quality of Service Classes
QoS 允许您对NSOperation、NSOperationQueue、NSThread对象、调度队列和pthreads（POSIX线程）要执行的工作进行分类。通过分配QoS来工作，您表明其重要性，系统对其进行优先级并相应安排。例如，系统比后台工作更早执行用户发起的工作，后台工作可以推迟到更优化的时间。

| Qos class | type of work and focus of Qos | Duration of the work to be performed |
|:-|:--|:--|
| User-interactive| work that is interacting with the user, such as operating on the main thread refereshing the user interface or performing animations if the work doesn't happen quickly the user interface may appear frozen  Focuses on respnseiveness and performance | work is virtually instantaneous |
| user -initiated | work that the user has initiated and requires immediate resultes suac as opening a saved document or performing an action when the user clickes something in the user interface the work is required in order to cuntinue user interaction focuses on responsiveness and performance | work is nearly instantaneous such as a few seconds or less |
| utility | work that may take some time to complete and doesn't require an immediate result, such as downloading or importing data,uitlity tasks typically have a progress bar that is visible to the user focuses on providing a blacalce between reponsiveness, preformance and energy efficiency | work takes a few secondes to a few minutes | 
| background | work that operates in the background and isn't visible to the user, such as indexing  synchronizing and backups focuses on energy efficiency | work takes sinificant time sha as minutes or hours | 

总结下：
user-interactive 适合瞬间完成的工作
user-initated 几乎瞬间完成，但还是需要几秒钟 适用于打开文档、用户点击
utility 需要几秒到几分钟  适用于下载，或者其他带有可见的进度
background 大量时间，几分钟或者几个小时

NSOperationQueue QoS inference and promotion rules
| situation | result |
|:- |:-|
| 队列没有分配QoS，队列中添加了带有QoS的操作。 | 队列及其其他操作（如果有的话）不会受到影响。|
| 队列分配了QoS，队列中添加了具有QoS的操作。| 如果新操作的QoS更高，则队列的QoS将提升。任何QoS较低的队列操作也会被提升。任何将来添加到队列中QoS较低的操作都将推断出较高的QoS。|
|通过修改qualityOfService来提高队列的Qos | 任何QoS较低的队列操作都升级到QoS较高。任何将来添加到队列中QoS较低的操作都将推断出较高的QoS。|
|通过修改qualityOfService来降低队列的Qos | 队列的任何操作都不受影响。未来添加到队列的任何操作都将推断较低的QoS，除非它们分配了较高的QoS，在这种情况下，它们将保留分配的QoS级别。|


##
一旦一个NSOperation开始运行了，您可以通过以下方式之一更改其QoS：
- 改变 NSOperation的 qualityOfService 属性的值， ： 这也会改变当前线程的Qos
- 往当前的NSOperationQueue中添加一个QoS更高的NSOperation，：这也会提升当前正在运行的NSOperation的QoS的值
- 使用 addDependency:往正在运行的NSOperation上添加QoS级别更高的NSOperation
- 使用 waitUntilFinished 或者 waitUntilAllOperationsAreFinished ，这将提升正在运行的NSOperation强制匹配调用上诉方法的QoS


>dispatch_queue_attr_t qosAttribute = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_UTILITY, 0);
dispatch_queue_t myQueue = dispatch_queue_create("com.YourApp.YourQueue", qosAttribute);

> qosClass = dispatch_queue_get_qos_class(myQueue, &relative);

>utilityGlobalQueue = dispatch_get_global_queue(QOS_CLASS_UTILITY, 0);

> dispatch_block_t myBlock;
myBlock = dispatch_block_create_with_qos_class(
     0, QOS_CLASS_UTILITY, -8, ^{…});
dispatch_async(myQueue, myBlock);

#### Priority Inversions
When high-priority work becomes dependent on lower priority work, or it becomes the result of lower priority work, a priority inversion occurs. As a result, blocking, spinning, and polling may occur.

在同步工作的情况下，系统将尝试在反转期间通过提高低优先级工作的QoS自动解决优先级反转。这将在以下情况下发生：

- When dispatch_sync() and dispatch_wait() are called for a block on a serial queue.
- 当调用pthread_mutex_lock()时，互斥体由QoS较低的线程持有。在这种情况下，持有锁的线程会被提升到调用方的QoS。然而，这种QoS促销不会在多个锁中进行。

在异步工作的情况下，系统将尝试解决串行队列上发生的优先级反转。

>重要
开发人员应首先确保优先级反转不会发生，这样系统就不会被迫尝试解决方案。


###### 主线程和当前线程
主线程根据其环境自动分配QoS。在应用程序中，主线程以用户交互的QoS级别运行。在XPC服务中，主线程以默认QoS运行。

>要检索主线程的QoS，请调用qos_class_main函数
qosClass = qos_class_main();

>要检索当前运行线程的QoS，请调用qos_class_self函数
qosClass = qos_class_self();



---
##### Minimize Timer Use

###### Get Event Notifications Without Using Timers
some apps us timers to monitor for changes to file contents network availability and other state changes TImers prevent the cpu form going to or staying in the idle state which increases energy usage and consumes battery power


Recommended : use an energy-efficent dispatch source to obtain file change notifications
>const char *myFile = [@"/Path/To/File" fileSystemRepresentation];
int fileDescriptor = open(myFile, O_EVTONLY);
dispatch_queue_t myQueue = dispatch_get_main_queue();
const uint64_t dispatchFlags = DISPATCH_VNODE_DELETE | DISPATCH_VNODE_WRITE;
dispatch_source_t mySource = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fileDescriptor, dispatchFlags, myQueue);
dispatch_source_set_event_handler(mySource, ^{
    [self checkForFile];
  });
dispatch_resume(mySource);

[dispatch sources](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ConcurrencyandApplicationDesign/ConcurrencyandApplicationDesign.html#//apple_ref/doc/uid/TP40008091-CH100-SW11) in [Concurrency Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091)
[File system programming guide](https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010672)
[local and remote notification programming guide](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/index.html#//apple_ref/doc/uid/TP40008194)
[DNS service Discovery programming guide](https://developer.apple.com/library/archive/documentation/Networking/Conceptual/dns_discovery_api/Introduction.html#//apple_ref/doc/uid/TP30000964) and [NSNetServices and CFNetServices Programming guide](https://developer.apple.com/library/archive/documentation/Networking/Conceptual/NSNetServiceProgGuide/Introduction.html#//apple_ref/doc/uid/TP40002736)

###### Use GCD Tools for Synchronization Instead of Timers

Recommended: Using an energy-efficient dispatch queue to synchronize threads
>myQueue = dispatch_queue_create("com.myapp.myq", DISPATCH_QUEUE_SERIAL);
dispatch_block_t block;
block = dispatch_block_create(0, ^{
    /* wait for network ... */
});
/* thread one */
void beginWork(void) {
  dispatch_async(myQueue, block);
};
/* thread two */
void waitForWorkToFinish(void) {
  dispatch_block_wait(block, DISPATCH_TIME_FOREVER);
  Block_release(block);
  [WorkController workDidFinish];
};


NOTE

For more information about using dispatch queues and other synchronization features of Grand Central Dispatch, see [Concurrency Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091) and Grand Central Dispatch (GCD) Reference. Also see [Synchronization](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8) in [Threading Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i). For optimal energy efficiency, classify dispatch queues for prioritization by the system. See [Specify a QoS for Dispatch Queues and Blocks](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/EnergyGuide-iOS/PrioritizeWorkWithQoS.html#//apple_ref/doc/uid/TP40015243-CH39-SW39) in [Prioritize Work with Quality of Service Classes](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/EnergyGuide-iOS/PrioritizeWorkWithQoS.html#//apple_ref/doc/uid/TP40015243-CH39-SW1).

###### If You Must Use a Timer, Employ It Efficiently

Many programming interfaces delay processes for specified periods of time. Any method or function to which you pass a relative or absolute deadline is probably a timer API
- High-level timer APIs include dispatch timer sources, CFRunLoopTimerCreate and other CFRunLoopTimer functions, the NSTimer class, and the performSelector:withObject:afterDelay: method.
- Low-level timer APIs include the functions sleep, usleep, nanosleep, pthread_cond_timedwait, select, poll, kevent, dispatch_after, and dispatch_semaphore_wait.

If you determine that your app requires a timer, follow these guidelines for drawing the least amount of energy:
- Use timers economically by specifying suitable timeouts.
- Invalidate repeating timers when they’re no longer needed.
- Set tolerances for when timers should fire.

###### Invalidate Repeating Timers You No Longer Need
###### Specify a Tolerance for Batching Timers Systemwide
>Specify a tolerance for the accuracy of when your timers fire. The system will use this flexibility to shift the execution of timers by small amounts of time—within their tolerances—so that multiple timers can be executed at the same time. Using this approach dramatically increases the amount of time that the processor spends idling while users detect no change in system responsiveness.

>dispatch_source_t myDispatchSourceTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, myQueue);
dispatch_source_set_timer(myDispatchSourceTimer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, NSEC_PER_SEC / 10);
dispatch_source_set_event_handler(myDispatchSourceTimer, ^{
    [self timerFired];
  }
);
dispatch_resume(myDispatchSourceTimer);

A general guideline is to set the tolerance to at least ten percent of the interval for a repeating timer, as in the examples above. Even a small amount of tolerance has a significant positive impact on the energy usage of your app.

---

### Minimize I/O

以下是一些优化应用程序中文件访问的准则：
- 尽量减少数据写入。仅在文件内容发生变化时写入文件，并尽可能将更改聚合为单个写入。如果只更改了几个字节，请避免写出整个文件。如果您经常更改大文件的一小部分，请考虑使用数据库来存储数据。
- 避免过于频繁地访问内存。如果您的应用程序保存状态信息，则仅在状态信息更改时才这样做。尽可能批量更改，以避免频繁地编写小更改。
- 尽可能按顺序读写数据。在文件中跳来跳去需要额外的时间来寻找新位置。
- 尽可能从文件中读取和写入更大的数据块，请记住一次读取过多的数据可能会导致其他问题。例如，在操作完成之前，读取32MB文件的全部内容可能会触发这些内容的分页。
- 对于读写大量数据，可以考虑使用dispatch_io，它提供了一个基于gcd的异步API来执行文件I/O。使用dispatch_io可以让您在高层次上指定您的数据需求，这样系统就可以优化您的访问。参见中央调度(GCD)参考。
- 如果您的数据由随机访问的结构化内容组成，请将其存储在数据库中，并使用SQLite或Core Data访问。如果您操作的数据量可能超过几兆字节，则使用数据库尤为重要。请参阅[SQLite软件库](http://www.sqlite.org/)和[CoreData编程指南](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075)。
- 了解系统如何缓存文件数据，并了解如何优化这些缓存的使用。除非您计划多次引用数据，否则请避免自己缓存数据。请参阅[文件系统编程指南](https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010672)中的系统有自己的[文件缓存机制](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/FileSystem/Articles/FilePerformance.html#//apple_ref/doc/uid/20001987-99732)。

###### Register for Power State Notifications
Your app can register to receive notifications when the power state (Low Power Mode is enabled or disabled) of the device changes. These notifications are posted on the global dispatch queue. 
>[[NSNotificationCenter defaultCenter] addObserver:self
   selector: @selector(yourMethodName:)
   name: NSProcessInfoPowerStateDidChangeNotification
   object: nil];

###### Determine the Power State
Your app can query the current power state at any time by accessing the isLowPowerModeEnabled property of the NSProcessInfo class, 
> if ([[NSProcessInfo processInfo] isLowPowerModeEnabled]) {
    // Low Power Mode is enabled. Start reducing activity to conserve energy.
} else {
    // Low Power Mode is not enabled.
};


##### Minimize Networking
Network operations may be unavoidable and essential to your app. In many cases, however, networking can be minimized by adhering to some general guidelines.

###### Reduce Data Sizes
Network transactions should be as small as possible to reduce overhead.

###### Reduce Media Quality and Size
If your app uploads, downloads, or streams media content, lower quality and smaller sizes reduce the amount of data being sent and received. Some apps let the user specify the quality and size. For example, when emailing a photo, Mail lets the user send a scaled version of the image at small, medium, or large size. The smallest size is the most energy efficient.

###### Compress Data
Use compression algorithms to compact data as much as possible before sending or receiving it.

###### Avoid Redundant Transfers
Your app shouldn’t repeatedly download the same data

###### Cache Data
Use caching to store infrequently updated data locally. Redownload the data only when it has changed or the user requests it. The NSURLCache and NSURLSession APIs can be used to implement in-memory and on-disk caches for URL request data.

###### Use Pausable and Resumable Transactions
The NSURLSession API lets you implement pause and resume functionality, without implementing caching

Check Signal Conditions
If network operations fail, use the SCNetworkReachability API to to see whether the host is available. If there are signal problems, alert the user or defer work until the host is available again.

To determine whether a host is reachable, check for the absence of the kSCNetworkReachabilityFlagsReachable reachability flag, 

```objc
#import "SystemConfiguration/SCNetworkReachability.h"
...
// Create a reachability object for the desired host
NSString *hostName = @"someHostName";
SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName
(NULL, [hostName UTF8String]);
// Create a place in memory for reachability flags
SCNetworkReachabilityFlags flags;
// Check the reachability of the host
SCNetworkReachabilityGetFlags(reachability, &flags);
// Release the reachability object
CFRelease(reachability);
// Check to see if the reachable flag is set
if ((flags & kSCNetworkReachabilityFlagsReachable) == 0) {
   // The target host is not reachable
   // Alert the user or defer the activity
}
```

###### Use Retry Policies
If a transaction fails, try again when the network becomes available. Use the SCNetworkReachability API to determine or be notified when the network is available again.

---
#### Defer Networking

###### Batch Transactions
- If your app streams video, download the entire file (or a large portion of the file) at once instead of requesting it in small pieces.
- If your app serves ads, download several at once and show them over a period of time, rather than downloading them as needed.
- If your app downloads email from a server, download multiple messages at once. Assume that the user will probably read most of them, rather than downloading each one individually as the user selects it.

###### Delay Deferrable Network Operations
- Activity is performed out-of-process. Because the network operations are performed by the system, your app stays responsive, letting the user continue doing other work. Your app also doesn’t need to continue running for activity to complete.
- Notifications keep your app informed. The system notifies your app when the activity is completed and if problems occur. Your app can even quit, relaunch, reconnect to a previous session, and resume receiving notifications. If your app isn’t running when the activities complete, or if authentication is required, the system can relaunch your app in the background.
- Network activity is performed efficiently. It’s inefficient to perform network activity over a slow connection. Bandwidth monitoring lets the system defer the activity when throughput falls below a certain threshold.
- Activity self-corrects. URL sessions can be automatically retried by the system when errors occur.

the background urlsession can be call by system, the app must in using or background.

###### Configure Background Session Options
Start by creating a background session configuration object. Give it a unique session identifier and flag it as a discretionary activity. Later, once the session is created, you can use the unique identifier to reconnect to the session even if your app is terminated and relaunched. 
```objc
NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration 
backgroundSessionConfigurationWithIdentifier:@"com.<YourApp>.<YourBackgroundSessionIdentifier>"];
// Set the configuration to discretionary
[configuration setDiscretionary: YES]; //this must set to tell system no activity immediate
// Set the configuration to run sometime in the next 18 hours
[configuration setTimeoutIntervalForResource: 18 * 60 * 60];

NSURLSession *backgroundSession = [NSURLSession sessionWithConfiguration:configuration 
delegate:self delegateQueue:nil];

NSURL *someURLToDownload = [NSURL URLWithString:<YourURLString>];
 
// Create a URL request
NSURLRequest *downloadRequest = [NSURLRequest requestWithURL:someURLToDownload];
 
// Add the request to the background session
NSURLSessionDownloadTask *downloadTask = [backgroundSession downloadTaskWithRequest:downloadRequest];
 
// Initiate the activity
[downloadTask resume];
```

Adjust Scheduling Tolerance for the Background Session
By default, the system allows up to seven days for a background session to run. This means that the activity will occur at a power-optimal time sometime within this timeframe. You can adjust the timeframe by changing the value (specified in seconds) of the timeoutIntervalForResource property of the configuration object. 

Since network conditions fluctuate regularly, it is highly recommended that a minimum of twelve hours be allocated for background activity to occur. Ideally, tolerance should be left at its default level of seven days, unless there is a valid reason to change it.

###### Get Notified About Background Session Activity
To receive callbacks when the background session receives a reply from the server, finishes downloading, or encounters an error, implement the appropriate delegate methods. Lists of available delegate methods are found in the following documents:
- [NSURLSessionDataDelegate Protocol Reference](https://developer.apple.com/documentation/foundation/nsurlsessiondatadelegate)
- [NSURLSessionDelegate Protocol Reference](https://developer.apple.com/documentation/foundation/urlsessiondelegate)
- [NSURLSessionDownloadDelegate Protocol Reference](https://developer.apple.com/documentation/foundation/urlsessiondownloaddelegate)
- [NSURLSessionTaskDelegate Protocol Reference](https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate)

```objc
- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask 
didFinishDownloadingToURL:(NSURL *)location {
   // Do any work following the completed download
};
```

###### Voice Over IP (VoIP) Best Practices
A Voice over Internet Protocol (VoIP) app lets the user make and receive phone calls using an Internet connection instead of the device’s cellular service. Because a VoIP app relies heavily on the network, it’s no surprise that making calls results in high energy use. When not in active use, however, a VoIP app should be completely idle to conserve energy.

Use VoIP Push Notifications to Avoid Persistent Connections
There are many advantages to using PushKit to receive VoIP pushes:
- The device is woken only when VoIP pushes occur, saving energy.
- Unlike standard push notifications, which the user must respond to before your app can perform an action, VoIP pushes go straight to your app for processing.
- VoIP pushes are considered high-priority notifications and are delivered without delay.
- VoIP pushes can include more data than what is provided with standard push notifications.
- Your app is automatically relaunched if it’s not running when a VoIP push is received.
- Your app is given runtime to process a push, even if your app is operating in the background.

---

### Use Graphics,Animations, and Video Efficiently

###### Avoid Extraneous Graphics and Animations
If your app uses only standard windows and controls, you probably don’t need to worry much about extraneous content updates, as the system APIs are designed to maximize energy efficiency. However, if you have custom windows and controls, be sure your drawing code performs efficiently. Your app shouldn’t refresh content unnecessarily, such as in obscured areas on screen, or through excessive use of animations.

Every time your app updates (or “draws”) content to screen, it requires the CPU, GPU, and screen to be active. Extraneous or inefficient drawing can pull system resources out of low-power states or prevent them from powering down altogether, resulting in significant energy use.
Follow these guidelines to optimize content refreshes:
- Reduce the number of views your app uses.
- Reduce the use of opacity, such as in views that exhibit a translucent blur. If you need to use opacity, avoid using it over content that changes frequently. Otherwise, energy cost is magnified, as both the background view and the translucent view must be updated whenever content changes.
- Eliminate drawing when your app or its content is not visible, such as when your app's content is obscured by other views, clipped, or offscreen.
- Use lower frame rates for animations whenever possible. For example, a high frame rate may make sense during game play, but a lower frame rate may be sufficient for a menu screen. Use a high frame rate only when the user experience calls for it.
- Use a consistent frame rate when performing an animation. For example, if your app displays 60 frames per second, maintain that frame rate throughout the lifetime of the animation.
- Avoid using multiple frame rates at once on screen. For example, don’t have a character in your game moving at 60 frames per second, while the clouds in the sky are moving at 30 frames per second. Use the same frame rate for both, even if it means raising one of the frame rates.
- Use recommended frameworks when developing games. These frameworks are optimized to provide great performance and optimal energy efficiency:
  - Use SpriteKit for 2D games. See [SpriteKit Programming Guide](https://developer.apple.com/library/archive/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013043) and [SpriteKit Framework Reference](https://developer.apple.com/documentation/spritekit).
  - Use SceneKit for casual 3D games. See [Scene Kit Framework Reference](https://developer.apple.com/documentation/scenekit) and Scene Kit Functions Reference.
  - Use Metal for highly immersive games. See [Metal Programming Guide](https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40014221), [Metal Framework Reference](https://developer.apple.com/documentation/metal), and Metal Functions Reference.


For guidelines on implementing windows and views, see [View Programming Guide for iOS](https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009503) and [View Controller Programming Guide for iOS](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457).


###### Restrict UI When Playing Full-Screen Video
iOS is optimized to conserve energy by managing resources efficiently while playing full-screen video. However, additional layers of UI above or below a playing video can degrade this optimization by ramping up additional resources, such as the GPU.

The standard set of video controls provided by the AVPlayerViewController class automatically hide during media playback. Apps should avoid adding additional layers (even hidden ones) above full screen video without good reason. Displaying controls and other UI elements over a full-screen video when the user requests them—such as via a tap—is fine and expected behavior. However, these elements should be removed when the user isn’t interacting with them.

For information about implementing full-screen video playback, see [AVKit Framework Reference](https://developer.apple.com/documentation/avkit).

--- 
#### Optimize Location and Motion
##### Reduce Location Accuracy And Duration
###### Request Quick Location Updates
If your app just needs a quick fix on the user’s location, it’s best to call the requestLocation method of the location manager object
Doing so automatically stops location services once the request has been fulfilled, letting location hardware power down if not being used elsewhere.

```objc
-(void)viewDidLoad {
  // Create a location manager object
  self.locationManager = [[CLLocationManager alloc] init];
 
  // Set the delegate
  self.locationManager.delegate = self;
}

-(void)getQuickLocationUpdate {
  // Request location authorization
  [self.locationManager requestWhenInUseAuthorization];
 
  // Request a location update
  [self.locationManager requestLocation];//当下面回调调用时，自动停止获取位置信息
  // Note: requestLocation may timeout and produce an error if
  // authorization has not yet been granted by the user
}
 
-(void)locationManager:(CLLocationManager *)manager
    didUpdateLocations:(NSArray *)locations {
  // Process the received location update
}
```

###### Stop Location Services When You Aren’t Using Them
除了提供逐个方向的导航应用程序外，大多数应用程序不需要一直使用定位服务。仅在需要时打开定位服务。然后，让它们打开足够长的时间，以便修复位置，然后再次关闭它们。除非用户在移动的车辆上，否则当前位置不应频繁更改为问题。如果您需要其他更新，您以后可以随时重新启动定位服务

To stop standard location updates, call the stopUpdatingLocation method of the location manager object. 
```objc
-(void)getLocationUpdate {
  // Create a location manager object
  self.locationManager = [[CLLocationManager alloc] init];
 
  // Set the delegate
  self.locationManager.delegate = self;
 
  // Request location authorization
  [self.locationManager requestWhenInUseAuthorization];
 
  // Start location updates
  [self.locationManager startUpdatingLocation];
}

-(void)locationManager:(CLLocationManager *)manager
    didUpdateLocations:(NSArray *)locations {
  // Get a fix on the user's location
  ...
 
  // Stop location updates
  [self.locationManager stopUpdatingLocation];
}
```

###### Reduce Accuracy of Standard Location Updates Whenever Possible
Standard location updates let you specify a degree of accuracy ranging from a few meters to a few kilometers by setting the desiredAccuracy property of the location manager object, as shown in Listing 14-3. Requesting higher accuracy than you need causes Core Location to power up additional hardware and waste power for unnecessary precision. Unless your app really needs to know the user’s position within a few meters, don’t set the accuracy level to best (kCLLocationAccuracyBest) or nearest ten meters (kCLLocationAccuracyNearestTenMeters). Also, be aware that Core Location typically provides more accurate data than you have requested. For example, when specifying an accuracy level of three kilometers (kCLLocationAccuracyThreeKilometers), you may receive accuracy within a hundred meters or so.

###### Stop Location Updates if Accuracy Doesn’t Match Expectations
如果你的应用接收到的更新没有达到预期的准确性，你的应用应该检查接收到的更新，并确定准确性是在不断提高还是保持不变。如果准确度没有提高，很有可能是目前无法达到期望的准确度水平。在这种情况下，停止位置更新，稍后再试，这样你的应用就不会持续导致位置硬件耗电。

##### Auto-Pause and Specify an Activity Type When Receiving Location Updates in the Background
In iOS 9 and later, regardless of deployment target, you must also set the allowsBackgroundLocationUpdates property of the location manager object to YES in order to receive background location updates. By default, this property is NO, and it should remain this way until a time when your app actively requires background location updates.

Make sure the location manager object’s pausesLocationUpdatesAutomatically property is set to YES to help conserve power.
```objc
-(void)startBackgroundLocationUpdates {
  // Create a location manager object
  self.locationManager = [[CLLocationManager alloc] init];
 
  // Set the delegate
  self.locationManager.delegate = self;
 
  // Request location authorization
  [self.locationManager requestWhenInUseAuthorization];
 
  // Set an accuracy level. The higher, the better for energy.
  self.locationManager.desiredAccuracy = kCLLocationAccuracyThreeKilometers;
 
  // Enable automatic pausing
  self.locationManager.pausesLocationUpdatesAutomatically = YES;
 
  // Specify the type of activity your app is currently performing
  self.locationManager.activityType = CLActivityTypeFitness;
 
  // Enable background location updates
  self.locationManager.allowsBackgroundLocationUpdates = YES;
 
  // Start location updates
  [self.locationManager startUpdatingLocation];
}
 
-(void)locationManager:(CLLocationManager *)manager
    didUpdateLocations:(NSArray *)locations {
  // Perform location-based activity
  ...
 
  // Stop location updates when they aren't needed anymore
  [self.locationManager stopUpdatingLocation];
 
  // Disable background location updates when they aren't needed anymore
  self.locationManager.allowsBackgroundLocationUpdates = NO;
}
```

###### Defer Location Updates When Running in the Background
On supported devices with GPS hardware, you can let the location manager defer the delivery of location updates when your app is in the background. For example, a fitness app that tracks the user’s location on a hiking trail can defer updates until the user has moved a certain distance or a certain period of time has elapsed. Then, it can process the updates all at once. You can use deferredLocationUpdatesAvailable to determine if a device supports deferred location updates.

To defer updates, call the location manager object’s allowDeferredLocationUpdatesUntilTraveled:timeout: method and pass it a distance and time that may elapse before the next location update is received. This method is typically called in the locationManager:didUpdateLocations: delegate method in order to defer again, if appropriate, when a deferred location update is received.

When a deferred location update is received, the locationManager:didFinishDeferredUpdatesWithError: delegate method is also called, and your app can use this as an opportunity to adjust behavior accordingly—such as increasing or decreasing the deferral distance and time—for the next update. 
```objc
-(void)startHikeLocationUpdates {
  // Create a location manager object
  self.locationManager = [[CLLocationManager alloc] init];
 
  // Set the delegate
  self.locationManager.delegate = self;
 
  // Request location authorization
  [self.locationManager requestWhenInUseAuthorization];
 
  // Specify the type of activity your app is currently performing
  self.locationManager.activityType = CLActivityTypeFitness;
 
  // Start location updates
  [self.locationManager startUpdatingLocation];
}
 
-(void)locationManager:(CLLocationManager *)manager
    didUpdateLocations:(NSArray *)locations {
  // Add the new locations to the hike
  [self.hike addLocations:locations];
 
  // Defer updates until the user hikes a certain distance or a period of time has passed
  if (!self.deferringUpdates) {
    CLLocationDistance distance = self.hike.goal - self.hike.distance;
    NSTimeInterval time = [self.nextUpdate timeIntervalSinceNow];
    [self.locationManager allowDeferredLocationUpdatesUntilTraveled:distance timeout:time];
    self.deferringUpdates = YES;
  } }
 
-(void)locationManager:(CLLocationManager *)manager
    didFinishDeferredUpdatesWithError:(NSError *)error {
  // Stop deferring updates
  self.deferringUpdates = NO;
 
  // Adjust for the next goal
}
```

###### Region and Beacon Monitoring
Core Location provides two methods for detecting a user’s entry to and exit from specific regions.

Geographical region monitoring provides entry and exit notifications for a specified location on the Earth.
Beacon monitoring provides entry and exit notifications when the user is within range of low-powered Bluetooth devices that are advertising iBeacon information.

访问监控

访问监控允许应用程序接收用户经常或长期访问特定地点的出入口通知，例如家庭、工作或最喜欢的咖啡店。

To begin monitoring for visits, assign a delegate to the location manager object and call its startMonitoringVisits method. Note that calling this method enables all visit updates in your app, not just ones for the current delegate. When enabled, visit events are delivered to the locationManager:didVisit: method of the delegate. If your app isn’t running when a visit event is delivered, your app is relaunched automatically. When visit location updates are no longer required, call stopMonitoringVisits,
```objc
-(void)startVisitMonitoring {
  // Create a location manager object
  self.locationManager = [[CLLocationManager alloc] init];
 
  // Set the delegate
  self.locationManager.delegate = self;
 
  // Request location authorization
  [self.locationManager requestAlwaysAuthorization];
 
  // Start monitoring for visits
  [self.locationManager startMonitoringVisits];
}
 
-(void)stopVisitMonitoring {
    [self.locationManager stopMonitoringVisits];
}
 
-(void)locationManager:(CLLocationManager *)manager didVisit:(CLVisit *)visit {
    // Perform location-based activity
    ...
}
```

###### Register for Significant-Change Location Updates Only as a Last Resort
如果GPS级别的准确性对您的应用程序不重要，您不需要持续跟踪，并且区域或访问监控不适合您的应用程序，您可以使用显著更改位置服务而不是标准位置服务。
区域和访问监控对于大多数用例来说已经足够了，在重大更改位置更新之前，应始终考虑。重大变化的位置更新全天候不间断地运行，直到您停止它们，如果不有效使用，实际上会导致更高的能源使用。

重大更改位置更新需要kCLAuthorizationStatusAuthorizedAlways的授权状态。

```objc
-(void)startSignificantChangeLocationUpdates {
  // Create a location manager object
  self.locationManager = [[CLLocationManager alloc] init];
 
  // Set the delegate
  self.locationManager.delegate = self;
 
  // Request location authorization
  [self.locationManager requestAlwaysAuthorization];
 
  // Start significant-change location updates
  [self.locationManager startMonitoringSignificantLocationChanges];
}
 
-(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations {
  // Perform location-based activity
  ...
 
  // Stop significant-change location updates when they aren't needed anymore
  [self.locationManager stopMonitoringSignificantLocationChanges];
}
```

###### Reduce the Frequency of Motion Updates
Users generate motion events whenever they move, shake, or tilt an iOS device.These motion events are detected by device hardware, such as the accelerometer, gyroscope, and magnetometer. 

####### Stop Orientation Change Notifications When No Longer Needed


Before registering for orientation change notifications, activate the accelerometer by calling the beginGeneratingDeviceOrientationNotifications method for the current device object. 
```objc
-(void) viewDidLoad {
  // Turn on the accelerometer
  [[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];
 
  //Register for orientation change notifications
  [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(orientationChanged:) 
  name:UIDeviceOrientationDidChangeNotification object:nil];
}
 
- (void)orientationChanged:(NSNotification *)notification {
  // Respond to changes in orientation here
}
 
-(void) viewDidDisappear: (BOOL) animated {
  // Stop receiving orientation change notifications
  [[NSNotificationCenter defaultCenter] removeObserver:self];
 
  // Turn off the accelerometer
  [[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications];
}
```

###### Request Fewer Continuous Motion Updates
The Core Motion framework provides APIs that let an app receive continuous motion updates in the form of accelerometer, gyroscope, and device motion (rotation, acceleration, and more) events. Once any of these APIs is initiated, the app can request motion updates at any time. It can also register to receive recurring updates.

```objc
-(void) viewDidLoad {
  [super viewDidLoad];
 
  // Create a Core Motion Manager object
  self.motionManager = [[CMMotionManager alloc] init];
}
 
- (void)startAccelerometerUpdates {
  // Check whether the accelerometer is available
  if ([self.motionManager isAccelerometerAvailable] == YES) {
 
    // Update the recurring update interval
    [self.motionManager setAccelerometerUpdateInterval:updateInterval];
 
    // Start accelerometer updates
    [self.motionManager startAccelerometerUpdatesToQueue:[NSOperationQueue mainQueue] withHandler:^(CMAccelerometerData *accelerometerData, NSError *error) {
 
      // Handler to process accelerometer data
 
    }];
  }
 
}
 
- (void)stopUpdates {
  // Check whether the accelerometer is available
  if ([self.motionManager isAccelerometerActive] == YES) {
 
    // Start accelerometer updates
    [self.motionManager stopAccelerometerUpdates];
 
  }
}
```

---
### Notification Best Practices
To the user, local and remote notifications are the same. They both just indicate that information is available. However, local and remote notifications have different effects on energy.

For detailed information about implementing notifications, see [Local and Remote Notification Programming Guide](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/index.html#//apple_ref/doc/uid/TP40008194).

###### Use Local Notifications Whenever Possible
If your app requires time-based notifications that don’t rely on external data, it should use local notifications to give network hardware a rest. As a side benefit, local notifications occur even if your app isn’t running. Local notifications still wake an idle device, though, so you should always avoid sending notifications unnecessarily.

###### Prioritize Remote Notification Delivery
Remote notifications provided by your server to the Apple Notification Service include a variety of elements, including payload data, an expiration date, a priority, and more. Remote notifications support two levels of push priority. One delivers the notification immediately. The other delays delivery of the notification until an energy-efficient time. Unless a notification truly requires an immediate delivery, use the deferred delivery method.


---
#### Bluetooth Best Practices 蓝牙的最佳实践
In general, minimize use of the radio whenever possible to reduce impact on other resources and the device’s battery. This can be done by buffering data instead of streaming it, and by batching transactions. The following additional guidelines will help you reduce unnecessary radio use.

[ Core Bluetooth Programming Guide.](https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html#//apple_ref/doc/uid/TP40013257)

###### Scan for Devices Only When Needed
When you call the scanForPeripheralsWithServices:options: method of the CBCentralManager class to discover remote peripherals that are advertising services, the device uses its radio to listen for advertising devices until explicitly told to stop. Unless you need to discover more devices, stop scanning for other devices once you have found one you want to connect to. Use the stopScan method of the CBCentralManager class to stop scanning for other devices.
```objc
-(void)beginScanningForDevice {
  // Create a Core Bluetooth Central Manager object
  self.myCentralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:nil];
 
  // Scan for peripherals
  [self.myCentralManager scanForPeripheralsWithServices:nil options:nil];
}
 
 
- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI {
 
  // Connect to the newly discovered device
 
  // Stop scanning for devices
  [self.myCentralManager stopScan];
}
```

###### 请求通知，而不是对特征值变化进行轮询
在大多数情况下，您的应用程序无法知道服务的特征值何时会在连接的设备上发生变化。您可以反复查询设备（投票）以检测更改，但更有效的方法是在发生更改时注册以接收通知。

通过将YES值传递给CBPeripheral类的setNotifyValue:forCharacteristic:方法来订阅特征值，如清单17-4所示。每当特征的值发生变化时，外围设备都会调用其委托对象的peripheral:didUpdateValueForCharacteristic:error:方法。

```objc
-(void)subscribeToCharacteristic {
  // Subscribe to a characteristic value
  [self.peripheral setNotifyValue:YES forCharacteristic:interestingCharacteristic];
}
 
- (void)peripheral:(CBPeripheral *)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error {
  // Process the characteristic value update
}
```

当您不再需要设备时，断开与设备的连接

为了防止您的应用程序不必要地使用设备的收音机，如果某个特性已停止提供通知或不再需要其他数据，请断开与外围设备的联系。通过将NO值传递给CBPeripheral类的setNotifyValue:forCharacteristic:方法来取消任何通知订阅。然后通过调用CBCentralManager类的cancelPeripheralConnection:方法断开与设备连接。
```objc
// Unsubscribe from a characteristic value
[self.peripheral setNotifyValue:NO forCharacteristic:interestingCharacteristic];
 
// Disconnect from the device
[self.myCentralManager cancelPeripheralConnection:peripheral];
```

在测试和调试应用程序时，请注意以下过度使用能源的迹象：
- 电池耗尽
- 当您期望应用程序空闲时的活动
- 响应或缓慢的用户界面
- 主线上大量的工作
- 动画的高利用率
- 高使用视图不透明度
- 交换
- 内存失速和缓存丢失
- 内存警告
- 锁定争执
- 过多的上下文切换
- 过度使用计时器
- 过度绘图到屏幕
- 过量或重复的小磁盘I/O
- 高间接费用通信，例如使用小数据包和缓冲区进行网络活动
- -预防设备睡眠



Xcode 包含的 Instruments 应用程序从运行中的应用程序中收集数据，并以图形时间线显示。您可以收集有关应用程序CPU使用率、磁盘活动、网络活动和图形操作等性能领域的数据。