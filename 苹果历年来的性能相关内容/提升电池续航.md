##### 电池续航
- 电池续航也是用户体验上很重要的不可缺的一部分

所有应用程序都消耗能源——无论何时执行网络操作、更新用户界面或在CPU上运行代码。随着用户越来越依赖电池电量，以及应用程序的激增，能源效率成为用户体验不可或缺的一部分。

良好的用户体验需要：
 - 电池续航能力很好
 - 惊人的速度
 - 快速响应


###### 尽可能减少后台工作
后台APP浪费能源的常见原因：
 - 后台活动完成后不通知系统
 - 播放无声音频
 - 执行位置更新
 - 与蓝牙配件交互
 - 推迟的下载

当app不活跃时或者退到后台，应当暂停App的活动

`
The applicationWillResignActive: method is called when your app enters an inactive state, such as when a phone call or text message comes in, or the user switches to another app and your app begins transitioning to a background state. This is a good place to pause activity, save data, and prepare for possible suspension. 
`
```Objective-c
- (void)applicationWillResignActive:(UIApplication *)application {
   // Halt operations, animations, and UI updates
}
```

`
The applicationDidEnterBackground: method is called immediately after your app enters a background state. Stop any operations, animations, and UI updates immediately.
`

>iOS allows only a few seconds for the applicationDidEnterBackground method to run. If your app needs more time to finish performing essential user initiated tasks, it should request more background execution time—the system allows up to a few more minutes of time on request. Call the beginBackgroundTaskWithExpirationHandler: method and pass it a handler, to be called if the extra time runs out. Next, run the remaining tasks on a dispatch queue or secondary thread.

>When background tasks are done, call the endBackgroundTask: method to let the system know processing is complete. If you don’t call this method and background execution time exhausts, then the completion handler is called to give you one last shot at wrapping things up. After that, your app is suspended.

>Once your app finishes performing background tasks, don’t wait for the system to call the expiration handler. Call endBackgroundTask: as soon as your app is done performing background tasks.


`
The applicationWillEnterForeground: method is called immediately before your app transitions from a background app to the active app. Start resuming operations, loading data, reinitializing the UI, and getting your app ready for the user.
`

```Objc
- (void)applicationWillEnterForeground:(UIApplication *)application {
   // Prepare to resume operations, animations, and UI updates
}
```

`
The applicationDidBecomeActive: method is called immediately after your app becomes the active app, after being launched by the system or transitioning from a background or inactive state. Fully resume any operations that were halted. 
`

---
##### Prioritize Work with Quality of Service Classes
QoS 允许您对NSOperation、NSOperationQueue、NSThread对象、调度队列和pthreads（POSIX线程）要执行的工作进行分类。通过分配QoS来工作，您表明其重要性，系统对其进行优先级并相应安排。例如，系统比后台工作更早执行用户发起的工作，后台工作可以推迟到更优化的时间。

| Qos class | type of work and focus of Qos | Duration of the work to be performed |
|:-|:--|:--|
| User-interactive| work that is interacting with the user, such as operating on the main thread refereshing the user interface or performing animations if the work doesn't happen quickly the user interface may appear frozen  Focuses on respnseiveness and performance | work is virtually instantaneous |
| user -initiated | work that the user has initiated and requires immediate resultes suac as opening a saved document or performing an action when the user clickes something in the user interface the work is required in order to cuntinue user interaction focuses on responsiveness and performance | work is nearly instantaneous such as a few seconds or less |
| utility | work that may take some time to complete and doesn't require an immediate result, such as downloading or importing data,uitlity tasks typically have a progress bar that is visible to the user focuses on providing a blacalce between reponsiveness, preformance and energy efficiency | work takes a few secondes to a few minutes | 
| background | work that operates in the background and isn't visible to the user, such as indexing  synchronizing and backups focuses on energy efficiency | work takes sinificant time sha as minutes or hours | 

总结下：
user-interactive 适合瞬间完成的工作
user-initated 几乎瞬间完成，但还是需要几秒钟 适用于打开文档、用户点击
utility 需要几秒到几分钟  适用于下载，或者其他带有可见的进度
background 大量时间，几分钟或者几个小时

NSOperationQueue QoS inference and promotion rules
| situation | result |
|:- |:-|
| 队列没有分配QoS，队列中添加了带有QoS的操作。 | 队列及其其他操作（如果有的话）不会受到影响。|
| 队列分配了QoS，队列中添加了具有QoS的操作。| 如果新操作的QoS更高，则队列的QoS将提升。任何QoS较低的队列操作也会被提升。任何将来添加到队列中QoS较低的操作都将推断出较高的QoS。|
|通过修改qualityOfService来提高队列的Qos | 任何QoS较低的队列操作都升级到QoS较高。任何将来添加到队列中QoS较低的操作都将推断出较高的QoS。|
|通过修改qualityOfService来降低队列的Qos | 队列的任何操作都不受影响。未来添加到队列的任何操作都将推断较低的QoS，除非它们分配了较高的QoS，在这种情况下，它们将保留分配的QoS级别。|


##
一旦一个NSOperation开始运行了，您可以通过以下方式之一更改其QoS：
- 改变 NSOperation的 qualityOfService 属性的值， ： 这也会改变当前线程的Qos
- 往当前的NSOperationQueue中添加一个QoS更高的NSOperation，：这也会提升当前正在运行的NSOperation的QoS的值
- 使用 addDependency:往正在运行的NSOperation上添加QoS级别更高的NSOperation
- 使用 waitUntilFinished 或者 waitUntilAllOperationsAreFinished ，这将提升正在运行的NSOperation强制匹配调用上诉方法的QoS


>dispatch_queue_attr_t qosAttribute = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_UTILITY, 0);
dispatch_queue_t myQueue = dispatch_queue_create("com.YourApp.YourQueue", qosAttribute);

> qosClass = dispatch_queue_get_qos_class(myQueue, &relative);

>utilityGlobalQueue = dispatch_get_global_queue(QOS_CLASS_UTILITY, 0);

> dispatch_block_t myBlock;
myBlock = dispatch_block_create_with_qos_class(
     0, QOS_CLASS_UTILITY, -8, ^{…});
dispatch_async(myQueue, myBlock);

#### Priority Inversions
When high-priority work becomes dependent on lower priority work, or it becomes the result of lower priority work, a priority inversion occurs. As a result, blocking, spinning, and polling may occur.

在同步工作的情况下，系统将尝试在反转期间通过提高低优先级工作的QoS自动解决优先级反转。这将在以下情况下发生：

- When dispatch_sync() and dispatch_wait() are called for a block on a serial queue.
- 当调用pthread_mutex_lock()时，互斥体由QoS较低的线程持有。在这种情况下，持有锁的线程会被提升到调用方的QoS。然而，这种QoS促销不会在多个锁中进行。

在异步工作的情况下，系统将尝试解决串行队列上发生的优先级反转。

>重要
开发人员应首先确保优先级反转不会发生，这样系统就不会被迫尝试解决方案。


###### 主线程和当前线程
主线程根据其环境自动分配QoS。在应用程序中，主线程以用户交互的QoS级别运行。在XPC服务中，主线程以默认QoS运行。

>要检索主线程的QoS，请调用qos_class_main函数
qosClass = qos_class_main();

>要检索当前运行线程的QoS，请调用qos_class_self函数
qosClass = qos_class_self();



---
##### Minimize Timer Use

###### Get Event Notifications Without Using Timers
some apps us timers to monitor for changes to file contents network availability and other state changes TImers prevent the cpu form going to or staying in the idle state which increases energy usage and consumes battery power


Recommended : use an energy-efficent dispatch source to obtain file change notifications
>const char *myFile = [@"/Path/To/File" fileSystemRepresentation];
int fileDescriptor = open(myFile, O_EVTONLY);
dispatch_queue_t myQueue = dispatch_get_main_queue();
const uint64_t dispatchFlags = DISPATCH_VNODE_DELETE | DISPATCH_VNODE_WRITE;
dispatch_source_t mySource = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fileDescriptor, dispatchFlags, myQueue);
dispatch_source_set_event_handler(mySource, ^{
    [self checkForFile];
  });
dispatch_resume(mySource);

[dispatch sources](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ConcurrencyandApplicationDesign/ConcurrencyandApplicationDesign.html#//apple_ref/doc/uid/TP40008091-CH100-SW11) in [Concurrency Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091)
[File system programming guide](https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010672)
[local and remote notification programming guide](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/index.html#//apple_ref/doc/uid/TP40008194)
[DNS service Discovery programming guide](https://developer.apple.com/library/archive/documentation/Networking/Conceptual/dns_discovery_api/Introduction.html#//apple_ref/doc/uid/TP30000964) and [NSNetServices and CFNetServices Programming guide](https://developer.apple.com/library/archive/documentation/Networking/Conceptual/NSNetServiceProgGuide/Introduction.html#//apple_ref/doc/uid/TP40002736)

###### Use GCD Tools for Synchronization Instead of Timers

Recommended: Using an energy-efficient dispatch queue to synchronize threads
>myQueue = dispatch_queue_create("com.myapp.myq", DISPATCH_QUEUE_SERIAL);
dispatch_block_t block;
block = dispatch_block_create(0, ^{
    /* wait for network ... */
});
/* thread one */
void beginWork(void) {
  dispatch_async(myQueue, block);
};
/* thread two */
void waitForWorkToFinish(void) {
  dispatch_block_wait(block, DISPATCH_TIME_FOREVER);
  Block_release(block);
  [WorkController workDidFinish];
};


NOTE

For more information about using dispatch queues and other synchronization features of Grand Central Dispatch, see [Concurrency Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091) and Grand Central Dispatch (GCD) Reference. Also see [Synchronization](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8) in [Threading Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i). For optimal energy efficiency, classify dispatch queues for prioritization by the system. See [Specify a QoS for Dispatch Queues and Blocks](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/EnergyGuide-iOS/PrioritizeWorkWithQoS.html#//apple_ref/doc/uid/TP40015243-CH39-SW39) in [Prioritize Work with Quality of Service Classes](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/EnergyGuide-iOS/PrioritizeWorkWithQoS.html#//apple_ref/doc/uid/TP40015243-CH39-SW1).

###### If You Must Use a Timer, Employ It Efficiently

Many programming interfaces delay processes for specified periods of time. Any method or function to which you pass a relative or absolute deadline is probably a timer API
- High-level timer APIs include dispatch timer sources, CFRunLoopTimerCreate and other CFRunLoopTimer functions, the NSTimer class, and the performSelector:withObject:afterDelay: method.
- Low-level timer APIs include the functions sleep, usleep, nanosleep, pthread_cond_timedwait, select, poll, kevent, dispatch_after, and dispatch_semaphore_wait.

If you determine that your app requires a timer, follow these guidelines for drawing the least amount of energy:
- Use timers economically by specifying suitable timeouts.
- Invalidate repeating timers when they’re no longer needed.
- Set tolerances for when timers should fire.

###### Invalidate Repeating Timers You No Longer Need
###### Specify a Tolerance for Batching Timers Systemwide
>Specify a tolerance for the accuracy of when your timers fire. The system will use this flexibility to shift the execution of timers by small amounts of time—within their tolerances—so that multiple timers can be executed at the same time. Using this approach dramatically increases the amount of time that the processor spends idling while users detect no change in system responsiveness.

>dispatch_source_t myDispatchSourceTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, myQueue);
dispatch_source_set_timer(myDispatchSourceTimer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, NSEC_PER_SEC / 10);
dispatch_source_set_event_handler(myDispatchSourceTimer, ^{
    [self timerFired];
  }
);
dispatch_resume(myDispatchSourceTimer);

A general guideline is to set the tolerance to at least ten percent of the interval for a repeating timer, as in the examples above. Even a small amount of tolerance has a significant positive impact on the energy usage of your app.

---

### Minimize I/O

以下是一些优化应用程序中文件访问的准则：
- 尽量减少数据写入。仅在文件内容发生变化时写入文件，并尽可能将更改聚合为单个写入。如果只更改了几个字节，请避免写出整个文件。如果您经常更改大文件的一小部分，请考虑使用数据库来存储数据。
- 避免过于频繁地访问内存。如果您的应用程序保存状态信息，则仅在状态信息更改时才这样做。尽可能批量更改，以避免频繁地编写小更改。
- 尽可能按顺序读写数据。在文件中跳来跳去需要额外的时间来寻找新位置。
- 尽可能从文件中读取和写入更大的数据块，请记住一次读取过多的数据可能会导致其他问题。例如，在操作完成之前，读取32MB文件的全部内容可能会触发这些内容的分页。
- 对于读写大量数据，可以考虑使用dispatch_io，它提供了一个基于gcd的异步API来执行文件I/O。使用dispatch_io可以让您在高层次上指定您的数据需求，这样系统就可以优化您的访问。参见中央调度(GCD)参考。
- 如果您的数据由随机访问的结构化内容组成，请将其存储在数据库中，并使用SQLite或Core Data访问。如果您操作的数据量可能超过几兆字节，则使用数据库尤为重要。请参阅[SQLite软件库](http://www.sqlite.org/)和[CoreData编程指南](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075)。
- 了解系统如何缓存文件数据，并了解如何优化这些缓存的使用。除非您计划多次引用数据，否则请避免自己缓存数据。请参阅[文件系统编程指南](https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010672)中的系统有自己的[文件缓存机制](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/FileSystem/Articles/FilePerformance.html#//apple_ref/doc/uid/20001987-99732)。

###### Register for Power State Notifications
Your app can register to receive notifications when the power state (Low Power Mode is enabled or disabled) of the device changes. These notifications are posted on the global dispatch queue. 
>[[NSNotificationCenter defaultCenter] addObserver:self
   selector: @selector(yourMethodName:)
   name: NSProcessInfoPowerStateDidChangeNotification
   object: nil];

###### Determine the Power State
Your app can query the current power state at any time by accessing the isLowPowerModeEnabled property of the NSProcessInfo class, 
> if ([[NSProcessInfo processInfo] isLowPowerModeEnabled]) {
    // Low Power Mode is enabled. Start reducing activity to conserve energy.
} else {
    // Low Power Mode is not enabled.
};


##### Minimize Networking
Network operations may be unavoidable and essential to your app. In many cases, however, networking can be minimized by adhering to some general guidelines.

###### Reduce Data Sizes
Network transactions should be as small as possible to reduce overhead.

###### Reduce Media Quality and Size
If your app uploads, downloads, or streams media content, lower quality and smaller sizes reduce the amount of data being sent and received. Some apps let the user specify the quality and size. For example, when emailing a photo, Mail lets the user send a scaled version of the image at small, medium, or large size. The smallest size is the most energy efficient.

###### Compress Data
Use compression algorithms to compact data as much as possible before sending or receiving it.

###### Avoid Redundant Transfers
Your app shouldn’t repeatedly download the same data

###### Cache Data
Use caching to store infrequently updated data locally. Redownload the data only when it has changed or the user requests it. The NSURLCache and NSURLSession APIs can be used to implement in-memory and on-disk caches for URL request data.

###### Use Pausable and Resumable Transactions
The NSURLSession API lets you implement pause and resume functionality, without implementing caching

Check Signal Conditions
If network operations fail, use the SCNetworkReachability API to to see whether the host is available. If there are signal problems, alert the user or defer work until the host is available again.

To determine whether a host is reachable, check for the absence of the kSCNetworkReachabilityFlagsReachable reachability flag, 

```objc
#import "SystemConfiguration/SCNetworkReachability.h"
...
// Create a reachability object for the desired host
NSString *hostName = @"someHostName";
SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName
(NULL, [hostName UTF8String]);
// Create a place in memory for reachability flags
SCNetworkReachabilityFlags flags;
// Check the reachability of the host
SCNetworkReachabilityGetFlags(reachability, &flags);
// Release the reachability object
CFRelease(reachability);
// Check to see if the reachable flag is set
if ((flags & kSCNetworkReachabilityFlagsReachable) == 0) {
   // The target host is not reachable
   // Alert the user or defer the activity
}
```

###### Use Retry Policies
If a transaction fails, try again when the network becomes available. Use the SCNetworkReachability API to determine or be notified when the network is available again.

---
#### Defer Networking

###### Batch Transactions
- If your app streams video, download the entire file (or a large portion of the file) at once instead of requesting it in small pieces.
- If your app serves ads, download several at once and show them over a period of time, rather than downloading them as needed.
- If your app downloads email from a server, download multiple messages at once. Assume that the user will probably read most of them, rather than downloading each one individually as the user selects it.

###### Delay Deferrable Network Operations
- Activity is performed out-of-process. Because the network operations are performed by the system, your app stays responsive, letting the user continue doing other work. Your app also doesn’t need to continue running for activity to complete.
- Notifications keep your app informed. The system notifies your app when the activity is completed and if problems occur. Your app can even quit, relaunch, reconnect to a previous session, and resume receiving notifications. If your app isn’t running when the activities complete, or if authentication is required, the system can relaunch your app in the background.
- Network activity is performed efficiently. It’s inefficient to perform network activity over a slow connection. Bandwidth monitoring lets the system defer the activity when throughput falls below a certain threshold.
- Activity self-corrects. URL sessions can be automatically retried by the system when errors occur.

the background urlsession can be call by system, the app must in using or background.

###### Configure Background Session Options
Start by creating a background session configuration object. Give it a unique session identifier and flag it as a discretionary activity. Later, once the session is created, you can use the unique identifier to reconnect to the session even if your app is terminated and relaunched. 
```objc
NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration 
backgroundSessionConfigurationWithIdentifier:@"com.<YourApp>.<YourBackgroundSessionIdentifier>"];
// Set the configuration to discretionary
[configuration setDiscretionary: YES]; //this must set to tell system no activity immediate
// Set the configuration to run sometime in the next 18 hours
[configuration setTimeoutIntervalForResource: 18 * 60 * 60];

NSURLSession *backgroundSession = [NSURLSession sessionWithConfiguration:configuration 
delegate:self delegateQueue:nil];

NSURL *someURLToDownload = [NSURL URLWithString:<YourURLString>];
 
// Create a URL request
NSURLRequest *downloadRequest = [NSURLRequest requestWithURL:someURLToDownload];
 
// Add the request to the background session
NSURLSessionDownloadTask *downloadTask = [backgroundSession downloadTaskWithRequest:downloadRequest];
 
// Initiate the activity
[downloadTask resume];
```

Adjust Scheduling Tolerance for the Background Session
By default, the system allows up to seven days for a background session to run. This means that the activity will occur at a power-optimal time sometime within this timeframe. You can adjust the timeframe by changing the value (specified in seconds) of the timeoutIntervalForResource property of the configuration object. 

Since network conditions fluctuate regularly, it is highly recommended that a minimum of twelve hours be allocated for background activity to occur. Ideally, tolerance should be left at its default level of seven days, unless there is a valid reason to change it.

###### Get Notified About Background Session Activity
To receive callbacks when the background session receives a reply from the server, finishes downloading, or encounters an error, implement the appropriate delegate methods. Lists of available delegate methods are found in the following documents:
- [NSURLSessionDataDelegate Protocol Reference](https://developer.apple.com/documentation/foundation/nsurlsessiondatadelegate)
- [NSURLSessionDelegate Protocol Reference](https://developer.apple.com/documentation/foundation/urlsessiondelegate)
- [NSURLSessionDownloadDelegate Protocol Reference](https://developer.apple.com/documentation/foundation/urlsessiondownloaddelegate)
- [NSURLSessionTaskDelegate Protocol Reference](https://developer.apple.com/documentation/foundation/nsurlsessiontaskdelegate)

```objc
- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask 
didFinishDownloadingToURL:(NSURL *)location {
   // Do any work following the completed download
};
```

###### Voice Over IP (VoIP) Best Practices
A Voice over Internet Protocol (VoIP) app lets the user make and receive phone calls using an Internet connection instead of the device’s cellular service. Because a VoIP app relies heavily on the network, it’s no surprise that making calls results in high energy use. When not in active use, however, a VoIP app should be completely idle to conserve energy.

Use VoIP Push Notifications to Avoid Persistent Connections
There are many advantages to using PushKit to receive VoIP pushes:
- The device is woken only when VoIP pushes occur, saving energy.
- Unlike standard push notifications, which the user must respond to before your app can perform an action, VoIP pushes go straight to your app for processing.
- VoIP pushes are considered high-priority notifications and are delivered without delay.
- VoIP pushes can include more data than what is provided with standard push notifications.
- Your app is automatically relaunched if it’s not running when a VoIP push is received.
- Your app is given runtime to process a push, even if your app is operating in the background.

---

### Use Graphics,Animations, and Video Efficiently

###### Avoid Extraneous Graphics and Animations
If your app uses only standard windows and controls, you probably don’t need to worry much about extraneous content updates, as the system APIs are designed to maximize energy efficiency. However, if you have custom windows and controls, be sure your drawing code performs efficiently. Your app shouldn’t refresh content unnecessarily, such as in obscured areas on screen, or through excessive use of animations.

Every time your app updates (or “draws”) content to screen, it requires the CPU, GPU, and screen to be active. Extraneous or inefficient drawing can pull system resources out of low-power states or prevent them from powering down altogether, resulting in significant energy use.
Follow these guidelines to optimize content refreshes:
- Reduce the number of views your app uses.
- Reduce the use of opacity, such as in views that exhibit a translucent blur. If you need to use opacity, avoid using it over content that changes frequently. Otherwise, energy cost is magnified, as both the background view and the translucent view must be updated whenever content changes.
- Eliminate drawing when your app or its content is not visible, such as when your app's content is obscured by other views, clipped, or offscreen.
- Use lower frame rates for animations whenever possible. For example, a high frame rate may make sense during game play, but a lower frame rate may be sufficient for a menu screen. Use a high frame rate only when the user experience calls for it.
- Use a consistent frame rate when performing an animation. For example, if your app displays 60 frames per second, maintain that frame rate throughout the lifetime of the animation.
- Avoid using multiple frame rates at once on screen. For example, don’t have a character in your game moving at 60 frames per second, while the clouds in the sky are moving at 30 frames per second. Use the same frame rate for both, even if it means raising one of the frame rates.
- Use recommended frameworks when developing games. These frameworks are optimized to provide great performance and optimal energy efficiency:
  - Use SpriteKit for 2D games. See [SpriteKit Programming Guide](https://developer.apple.com/library/archive/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013043) and [SpriteKit Framework Reference](https://developer.apple.com/documentation/spritekit).
  - Use SceneKit for casual 3D games. See [Scene Kit Framework Reference](https://developer.apple.com/documentation/scenekit) and Scene Kit Functions Reference.
  - Use Metal for highly immersive games. See [Metal Programming Guide](https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40014221), [Metal Framework Reference](https://developer.apple.com/documentation/metal), and Metal Functions Reference.


For guidelines on implementing windows and views, see [View Programming Guide for iOS](https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009503) and [View Controller Programming Guide for iOS](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457).