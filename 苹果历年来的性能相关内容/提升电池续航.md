##### 电池续航
- 电池续航也是用户体验上很重要的不可缺的一部分

所有应用程序都消耗能源——无论何时执行网络操作、更新用户界面或在CPU上运行代码。随着用户越来越依赖电池电量，以及应用程序的激增，能源效率成为用户体验不可或缺的一部分。

良好的用户体验需要：
 - 电池续航能力很好
 - 惊人的速度
 - 快速响应


###### 尽可能减少后台工作
后台APP浪费能源的常见原因：
 - 后台活动完成后不通知系统
 - 播放无声音频
 - 执行位置更新
 - 与蓝牙配件交互
 - 推迟的下载

当app不活跃时或者退到后台，应当暂停App的活动

`
The applicationWillResignActive: method is called when your app enters an inactive state, such as when a phone call or text message comes in, or the user switches to another app and your app begins transitioning to a background state. This is a good place to pause activity, save data, and prepare for possible suspension. 
`
```Objective-c
- (void)applicationWillResignActive:(UIApplication *)application {
   // Halt operations, animations, and UI updates
}
```

`
The applicationDidEnterBackground: method is called immediately after your app enters a background state. Stop any operations, animations, and UI updates immediately.
`

>iOS allows only a few seconds for the applicationDidEnterBackground method to run. If your app needs more time to finish performing essential user initiated tasks, it should request more background execution time—the system allows up to a few more minutes of time on request. Call the beginBackgroundTaskWithExpirationHandler: method and pass it a handler, to be called if the extra time runs out. Next, run the remaining tasks on a dispatch queue or secondary thread.

>When background tasks are done, call the endBackgroundTask: method to let the system know processing is complete. If you don’t call this method and background execution time exhausts, then the completion handler is called to give you one last shot at wrapping things up. After that, your app is suspended.

>Once your app finishes performing background tasks, don’t wait for the system to call the expiration handler. Call endBackgroundTask: as soon as your app is done performing background tasks.


`
The applicationWillEnterForeground: method is called immediately before your app transitions from a background app to the active app. Start resuming operations, loading data, reinitializing the UI, and getting your app ready for the user.
`

```Objc
- (void)applicationWillEnterForeground:(UIApplication *)application {
   // Prepare to resume operations, animations, and UI updates
}
```

`
The applicationDidBecomeActive: method is called immediately after your app becomes the active app, after being launched by the system or transitioning from a background or inactive state. Fully resume any operations that were halted. 
`

---
##### Prioritize Work with Quality of Service Classes
QoS 允许您对NSOperation、NSOperationQueue、NSThread对象、调度队列和pthreads（POSIX线程）要执行的工作进行分类。通过分配QoS来工作，您表明其重要性，系统对其进行优先级并相应安排。例如，系统比后台工作更早执行用户发起的工作，后台工作可以推迟到更优化的时间。

| Qos class | type of work and focus of Qos | Duration of the work to be performed |
|:-|:--|:--|
| User-interactive| work that is interacting with the user, such as operating on the main thread refereshing the user interface or performing animations if the work doesn't happen quickly the user interface may appear frozen  Focuses on respnseiveness and performance | work is virtually instantaneous |
| user -initiated | work that the user has initiated and requires immediate resultes suac as opening a saved document or performing an action when the user clickes something in the user interface the work is required in order to cuntinue user interaction focuses on responsiveness and performance | work is nearly instantaneous such as a few seconds or less |
| utility | work that may take some time to complete and doesn't require an immediate result, such as downloading or importing data,uitlity tasks typically have a progress bar that is visible to the user focuses on providing a blacalce between reponsiveness, preformance and energy efficiency | work takes a few secondes to a few minutes | 
| background | work that operates in the background and isn't visible to the user, such as indexing  synchronizing and backups focuses on energy efficiency | work takes sinificant time sha as minutes or hours | 

总结下：
user-interactive 适合瞬间完成的工作
user-initated 几乎瞬间完成，但还是需要几秒钟 适用于打开文档、用户点击
utility 需要几秒到几分钟  适用于下载，或者其他带有可见的进度
background 大量时间，几分钟或者几个小时

NSOperationQueue QoS inference and promotion rules
| situation | result |
|:- |:-|
| 队列没有分配QoS，队列中添加了带有QoS的操作。 | 队列及其其他操作（如果有的话）不会受到影响。|
| 队列分配了QoS，队列中添加了具有QoS的操作。| 如果新操作的QoS更高，则队列的QoS将提升。任何QoS较低的队列操作也会被提升。任何将来添加到队列中QoS较低的操作都将推断出较高的QoS。|
|通过修改qualityOfService来提高队列的Qos | 任何QoS较低的队列操作都升级到QoS较高。任何将来添加到队列中QoS较低的操作都将推断出较高的QoS。|
|通过修改qualityOfService来降低队列的Qos | 队列的任何操作都不受影响。未来添加到队列的任何操作都将推断较低的QoS，除非它们分配了较高的QoS，在这种情况下，它们将保留分配的QoS级别。|


##
一旦一个NSOperation开始运行了，您可以通过以下方式之一更改其QoS：
- 改变 NSOperation的 qualityOfService 属性的值， ： 这也会改变当前线程的Qos
- 往当前的NSOperationQueue中添加一个QoS更高的NSOperation，：这也会提升当前正在运行的NSOperation的QoS的值
- 使用 addDependency:往正在运行的NSOperation上添加QoS级别更高的NSOperation
- 使用 waitUntilFinished 或者 waitUntilAllOperationsAreFinished ，这将提升正在运行的NSOperation强制匹配调用上诉方法的QoS


>dispatch_queue_attr_t qosAttribute = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT, QOS_CLASS_UTILITY, 0);
dispatch_queue_t myQueue = dispatch_queue_create("com.YourApp.YourQueue", qosAttribute);

> qosClass = dispatch_queue_get_qos_class(myQueue, &relative);

>utilityGlobalQueue = dispatch_get_global_queue(QOS_CLASS_UTILITY, 0);

> dispatch_block_t myBlock;
myBlock = dispatch_block_create_with_qos_class(
     0, QOS_CLASS_UTILITY, -8, ^{…});
dispatch_async(myQueue, myBlock);

#### Priority Inversions
When high-priority work becomes dependent on lower priority work, or it becomes the result of lower priority work, a priority inversion occurs. As a result, blocking, spinning, and polling may occur.

在同步工作的情况下，系统将尝试在反转期间通过提高低优先级工作的QoS自动解决优先级反转。这将在以下情况下发生：

- When dispatch_sync() and dispatch_wait() are called for a block on a serial queue.
- 当调用pthread_mutex_lock()时，互斥体由QoS较低的线程持有。在这种情况下，持有锁的线程会被提升到调用方的QoS。然而，这种QoS促销不会在多个锁中进行。

在异步工作的情况下，系统将尝试解决串行队列上发生的优先级反转。

>重要
开发人员应首先确保优先级反转不会发生，这样系统就不会被迫尝试解决方案。


###### 主线程和当前线程
主线程根据其环境自动分配QoS。在应用程序中，主线程以用户交互的QoS级别运行。在XPC服务中，主线程以默认QoS运行。

>要检索主线程的QoS，请调用qos_class_main函数
qosClass = qos_class_main();

>要检索当前运行线程的QoS，请调用qos_class_self函数
qosClass = qos_class_self();



---
##### Minimize Timer Use

###### Get Event Notifications Without Using Timers
some apps us timers to monitor for changes to file contents network availability and other state changes TImers prevent the cpu form going to or staying in the idle state which increases energy usage and consumes battery power


Recommended : use an energy-efficent dispatch source to obtain file change notifications
>const char *myFile = [@"/Path/To/File" fileSystemRepresentation];
int fileDescriptor = open(myFile, O_EVTONLY);
dispatch_queue_t myQueue = dispatch_get_main_queue();
const uint64_t dispatchFlags = DISPATCH_VNODE_DELETE | DISPATCH_VNODE_WRITE;
dispatch_source_t mySource = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fileDescriptor, dispatchFlags, myQueue);
dispatch_source_set_event_handler(mySource, ^{
    [self checkForFile];
  });
dispatch_resume(mySource);

[dispatch sources](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/ConcurrencyandApplicationDesign/ConcurrencyandApplicationDesign.html#//apple_ref/doc/uid/TP40008091-CH100-SW11) in [Concurrency Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091)
[File system programming guide](https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010672)
[local and remote notification programming guide](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/index.html#//apple_ref/doc/uid/TP40008194)
[DNS service Discovery programming guide](https://developer.apple.com/library/archive/documentation/Networking/Conceptual/dns_discovery_api/Introduction.html#//apple_ref/doc/uid/TP30000964) and [NSNetServices and CFNetServices Programming guide](https://developer.apple.com/library/archive/documentation/Networking/Conceptual/NSNetServiceProgGuide/Introduction.html#//apple_ref/doc/uid/TP40002736)

###### Use GCD Tools for Synchronization Instead of Timers

Recommended: Using an energy-efficient dispatch queue to synchronize threads
>myQueue = dispatch_queue_create("com.myapp.myq", DISPATCH_QUEUE_SERIAL);
dispatch_block_t block;
block = dispatch_block_create(0, ^{
    /* wait for network ... */
});
/* thread one */
void beginWork(void) {
  dispatch_async(myQueue, block);
};
/* thread two */
void waitForWorkToFinish(void) {
  dispatch_block_wait(block, DISPATCH_TIME_FOREVER);
  Block_release(block);
  [WorkController workDidFinish];
};


NOTE

For more information about using dispatch queues and other synchronization features of Grand Central Dispatch, see [Concurrency Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091) and Grand Central Dispatch (GCD) Reference. Also see [Synchronization](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8) in [Threading Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i). For optimal energy efficiency, classify dispatch queues for prioritization by the system. See [Specify a QoS for Dispatch Queues and Blocks](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/EnergyGuide-iOS/PrioritizeWorkWithQoS.html#//apple_ref/doc/uid/TP40015243-CH39-SW39) in [Prioritize Work with Quality of Service Classes](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/EnergyGuide-iOS/PrioritizeWorkWithQoS.html#//apple_ref/doc/uid/TP40015243-CH39-SW1).

###### If You Must Use a Timer, Employ It Efficiently

Many programming interfaces delay processes for specified periods of time. Any method or function to which you pass a relative or absolute deadline is probably a timer API
- High-level timer APIs include dispatch timer sources, CFRunLoopTimerCreate and other CFRunLoopTimer functions, the NSTimer class, and the performSelector:withObject:afterDelay: method.
- Low-level timer APIs include the functions sleep, usleep, nanosleep, pthread_cond_timedwait, select, poll, kevent, dispatch_after, and dispatch_semaphore_wait.

If you determine that your app requires a timer, follow these guidelines for drawing the least amount of energy:
- Use timers economically by specifying suitable timeouts.
- Invalidate repeating timers when they’re no longer needed.
- Set tolerances for when timers should fire.

###### Invalidate Repeating Timers You No Longer Need
###### Specify a Tolerance for Batching Timers Systemwide
>Specify a tolerance for the accuracy of when your timers fire. The system will use this flexibility to shift the execution of timers by small amounts of time—within their tolerances—so that multiple timers can be executed at the same time. Using this approach dramatically increases the amount of time that the processor spends idling while users detect no change in system responsiveness.

>dispatch_source_t myDispatchSourceTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, myQueue);
dispatch_source_set_timer(myDispatchSourceTimer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, NSEC_PER_SEC / 10);
dispatch_source_set_event_handler(myDispatchSourceTimer, ^{
    [self timerFired];
  }
);
dispatch_resume(myDispatchSourceTimer);

A general guideline is to set the tolerance to at least ten percent of the interval for a repeating timer, as in the examples above. Even a small amount of tolerance has a significant positive impact on the energy usage of your app.

---

### Minimize I/O

以下是一些优化应用程序中文件访问的准则：
- 尽量减少数据写入。仅在文件内容发生变化时写入文件，并尽可能将更改聚合为单个写入。如果只更改了几个字节，请避免写出整个文件。如果您经常更改大文件的一小部分，请考虑使用数据库来存储数据。
- 避免过于频繁地访问内存。如果您的应用程序保存状态信息，则仅在状态信息更改时才这样做。尽可能批量更改，以避免频繁地编写小更改。
- 尽可能按顺序读写数据。在文件中跳来跳去需要额外的时间来寻找新位置。
- 尽可能从文件中读取和写入更大的数据块，请记住一次读取过多的数据可能会导致其他问题。例如，在操作完成之前，读取32MB文件的全部内容可能会触发这些内容的分页。
- 对于读写大量数据，可以考虑使用dispatch_io，它提供了一个基于gcd的异步API来执行文件I/O。使用dispatch_io可以让您在高层次上指定您的数据需求，这样系统就可以优化您的访问。参见中央调度(GCD)参考。
- 如果您的数据由随机访问的结构化内容组成，请将其存储在数据库中，并使用SQLite或Core Data访问。如果您操作的数据量可能超过几兆字节，则使用数据库尤为重要。请参阅[SQLite软件库](http://www.sqlite.org/)和[CoreData编程指南](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075)。
- 了解系统如何缓存文件数据，并了解如何优化这些缓存的使用。除非您计划多次引用数据，否则请避免自己缓存数据。请参阅[文件系统编程指南](https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010672)中的系统有自己的[文件缓存机制](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/FileSystem/Articles/FilePerformance.html#//apple_ref/doc/uid/20001987-99732)。

###### Register for Power State Notifications
Your app can register to receive notifications when the power state (Low Power Mode is enabled or disabled) of the device changes. These notifications are posted on the global dispatch queue. 
>[[NSNotificationCenter defaultCenter] addObserver:self
   selector: @selector(yourMethodName:)
   name: NSProcessInfoPowerStateDidChangeNotification
   object: nil];

###### Determine the Power State
Your app can query the current power state at any time by accessing the isLowPowerModeEnabled property of the NSProcessInfo class, 
> if ([[NSProcessInfo processInfo] isLowPowerModeEnabled]) {
    // Low Power Mode is enabled. Start reducing activity to conserve energy.
} else {
    // Low Power Mode is not enabled.
};